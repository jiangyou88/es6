## 基本用法
- ES6之前，不能直接为闪烁的参数指定默认值，只能采用变通的方法
## 与解构赋值默认值结合使用

## 函数的length属性
- 指定了默认值以后，函数length属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值后，length属性将失真
```
console.log((function(a){}).length);//1
console.log((function (a=5){}).length);//0
console.log((function (a,b,c=5){}).length);//2
```
## 作用域
- 一旦慎重了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域(contxt)。等到初始化结束，这个作用域就会消失，这种语法行为，在不设置参数默认值时，是不会出现
## rest参数
- ES6引入rest参数(形式为...变量名)，用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中
- 注意，rest参数之后不能再有其他参数(即只能是最后一个参数)，否则会报错
- 函数的length属性，不包括rest参数
## 严格模式
- ES6规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显示设定为严格模式，否则会报错
```
// 报错
function doSomething(a, b = a) {
  'use strict';
  // code
}

// 报错
const doSomething = function ({a, b}) {
  'use strict';
  // code
};

// 报错
const doSomething = (...a) => {
  'use strict';
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    'use strict';
    // code
  }
};
```
- 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数，但是,函数执行的时候，先执行函数参数，然后在执行函数体，这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行

## name属性
- 函数的name属性，返回该函数的函数名
```
function foo(){}
console.log(foo,name)//'foo'
```
- 需要注意的是，ES6对这个属性的行为做出了一些修改，如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名

## 箭头函数
- ES6允许使用"箭头(=>)定义函数"
- 箭头函数的一个用处是简化回调函数

## 箭头函数使用注意点：
- 1.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
- 2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误
- 3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替
- 4.不可以使用yield命令，因此箭头函数不能用作Generator函数
- 由于箭头函数没有自己的this，所以当然也就不能用call(),apply(),bind()这些方法去改变this的指向

## 双冒号运算符